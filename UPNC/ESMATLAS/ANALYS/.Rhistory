nb_values_sup_90 <- sum(datafold_UPNC$pLDDT > 90)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPNC$pLDDT > 70 & datafold_UPNC$pLDDT < 90)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPNC$pLDDT > 50 & datafold_UPNC$pLDDT < 70)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPNC$pLDDT < 50)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPNC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ALPHADB/ANALYS"
setwd(directories)
# Charger le package ggplot2
library(ggplot2)
# Charger le dataframe classbf
classbf <- read.table("pLDDT_class.txt", header = FALSE)
colnames(classbf) <- c("pLDDT", "CLASS")
# Charger le package ggplot2
library(ggplot2)
ggplot(classbf, aes(x = pLDDT, fill = CLASS)) +
geom_histogram(position = "identity", bins = 20, alpha = 0.7, color = "black") +
labs(title = "Distribution des pLDDT des UPC en fonction des CLASS", x = "pLDDT", y = "Fréquence") +
theme_minimal() +
facet_wrap(~CLASS, scales = "free_y") +
coord_cartesian(ylim = c(0, 500)) +
theme(
plot.title = element_text(size = 17),  # Ajuster la taille du titre du graphique principal
strip.text = element_text(size = 14)   # Ajuster la taille des titres des facettes
)
# Calculer la valeur moyenne pour chaque groupe
moyennes_par_groupe <- aggregate(pLDDT ~ CLASS, data = classbf, FUN = mean)
# Afficher les résultats
print(moyennes_par_groupe)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPC <- read.table("alld_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("alle_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 800)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
## UPC
nb_values_sup_90 <- sum(datafold_UPC$pLDDT > 0.9)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPC$pLDDT > 0.7 & datafold_UPC$pLDDT < 0.9)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPC$pLDDT > 0.5 & datafold_UPC$pLDDT < 0.7)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPC$pLDDT < 0.5)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
## UPNC
nb_values_sup_90 <- sum(datafold_UPNC$pLDDT > 0.9)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPNC$pLDDT > 0.7 & datafold_UPNC$pLDDT < 0.9)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPNC$pLDDT > 0.5 & datafold_UPNC$pLDDT < 0.7)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPNC$pLDDT < 0.5)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPNC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ESMATLAS/ANALYS"
setwd(directories)
# Charger le package ggplot2
library(ggplot2)
# Charger le dataframe classbf
classbf <- read.table("pLDDT_class.txt", header = FALSE)
colnames(classbf) <- c("pLDDT", "CLASS")
# Charger le package ggplot2
library(ggplot2)
ggplot(classbf, aes(x = pLDDT, fill = CLASS)) +
geom_histogram(position = "identity", bins = 20, alpha = 0.7, color = "black") +
labs(title = "Distribution des pLDDT des UPC en fonction des CLASS", x = "pLDDT", y = "Fréquence") +
theme_minimal() +
facet_wrap(~CLASS, scales = "free_y") +
coord_cartesian(ylim = c(0, 300)) +
theme(
plot.title = element_text(size = 17),  # Ajuster la taille du titre du graphique principal
strip.text = element_text(size = 14)   # Ajuster la taille des titres des facettes
)
# Calculer la valeur moyenne pour chaque groupe
moyennes_par_groupe <- aggregate(pLDDT ~ CLASS, data = classbf, FUN = mean)
# Afficher les résultats
print(moyennes_par_groupe)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ALPHADB/ANALYS"
setwd(directories)
datafold_UPC <- read.table("allb_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ALPHADB/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("allc_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 2000)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
## UPC
nb_values_sup_90 <- sum(datafold_UPC$pLDDT > 90)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPC$pLDDT > 70 & datafold_UPC$pLDDT < 90)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPC$pLDDT > 50 & datafold_UPC$pLDDT < 70)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPC$pLDDT < 50)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
## UPNC
nb_values_sup_90 <- sum(datafold_UPNC$pLDDT > 90)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPNC$pLDDT > 70 & datafold_UPNC$pLDDT < 90)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPNC$pLDDT > 50 & datafold_UPNC$pLDDT < 70)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPNC$pLDDT < 50)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPNC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ALPHADB/ANALYS"
setwd(directories)
# Charger le package ggplot2
library(ggplot2)
# Charger le dataframe classbf
classbf <- read.table("pLDDT_class.txt", header = FALSE)
colnames(classbf) <- c("pLDDT", "CLASS")
# Charger le package ggplot2
library(ggplot2)
ggplot(classbf, aes(x = pLDDT, fill = CLASS)) +
geom_histogram(position = "identity", bins = 20, alpha = 0.7, color = "black") +
labs(title = "Distribution des pLDDT des UPC en fonction des CLASS", x = "pLDDT", y = "Fréquence") +
theme_minimal() +
facet_wrap(~CLASS, scales = "free_y") +
coord_cartesian(ylim = c(0, 500)) +
theme(
plot.title = element_text(size = 17),  # Ajuster la taille du titre du graphique principal
strip.text = element_text(size = 14)   # Ajuster la taille des titres des facettes
)
# Calculer la valeur moyenne pour chaque groupe
moyennes_par_groupe <- aggregate(pLDDT ~ CLASS, data = classbf, FUN = mean)
# Afficher les résultats
print(moyennes_par_groupe)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPC <- read.table("alld_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("alle_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 800)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
## UPC
nb_values_sup_90 <- sum(datafold_UPC$pLDDT > 0.9)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPC$pLDDT > 0.7 & datafold_UPC$pLDDT < 0.9)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPC$pLDDT > 0.5 & datafold_UPC$pLDDT < 0.7)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPC$pLDDT < 0.5)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
## UPNC
nb_values_sup_90 <- sum(datafold_UPNC$pLDDT > 0.9)
percent_sup_90 <- round((nb_values_sup_90 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very high :", percent_sup_90, "%"))
nb_values_sup_70 <- sum(datafold_UPNC$pLDDT > 0.7 & datafold_UPNC$pLDDT < 0.9)
percent_sup_70 <- round((nb_values_sup_70 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("High :", percent_sup_70, "%"))
nb_values_sup_50 <- sum(datafold_UPNC$pLDDT > 0.5 & datafold_UPNC$pLDDT < 0.7)
percent_sup_50 <- round((nb_values_sup_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Low :", percent_sup_50, "%"))
nb_values_inf_50 <- sum(datafold_UPNC$pLDDT < 0.5)
percent_inf_50 <- round((nb_values_inf_50 / length(datafold_UPNC$pLDDT))*100, 2)
print(paste("Very low :", percent_inf_50))
# Vecteur des valeurs
values <- c("Very high" = percent_sup_90, "High" = percent_sup_70, "Low" = percent_sup_50, "Very low" = percent_inf_50)
# Couleurs pour le camembert
colors <- c("#1F78B4", "#A6CEE3", "#FFD92F", "#FF7F00")
# Nom des portions
labels <- names(values)
# Créer un diagramme en camembert avec une taille plus grande
par(mfrow = c(1,1))
par(mar = c(5, 0, 4, 2))  # Ajuster les marges pour éviter le chevauchement avec le titre
pie(values, labels = labels, col = colors, main = "Distribution des UPNC (%) en fonction du score de confiance : pLDDT", cex = 1.4, radius = 1, cex.main = 2)
legend_labels <- paste(labels, ": ", values, "%")
# Ajouter une légende
legend("topright", legend = legend_labels, fill = colors, cex = 1,7, bty = "n")  # bty = "n" pour supprimer la boîte autour de la légende
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ESMATLAS/ANALYS"
setwd(directories)
# Charger le package ggplot2
library(ggplot2)
# Charger le dataframe classbf
classbf <- read.table("pLDDT_class.txt", header = FALSE)
colnames(classbf) <- c("pLDDT", "CLASS")
# Charger le package ggplot2
library(ggplot2)
ggplot(classbf, aes(x = pLDDT, fill = CLASS)) +
geom_histogram(position = "identity", bins = 20, alpha = 0.7, color = "black") +
labs(title = "Distribution des pLDDT des UPC en fonction des CLASS", x = "pLDDT", y = "Fréquence") +
theme_minimal() +
facet_wrap(~CLASS, scales = "free_y") +
coord_cartesian(ylim = c(0, 300)) +
theme(
plot.title = element_text(size = 17),  # Ajuster la taille du titre du graphique principal
strip.text = element_text(size = 14)   # Ajuster la taille des titres des facettes
)
# Calculer la valeur moyenne pour chaque groupe
moyennes_par_groupe <- aggregate(pLDDT ~ CLASS, data = classbf, FUN = mean)
# Afficher les résultats
print(moyennes_par_groupe)
# Charger les données UPC
directories_UPC <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/PDB/ANALYS"
setwd(directories_UPC)
data_UPC <- read.table("all_mean.txt", header = FALSE, col.names = c("B_factor"))
# Charger les données UPNC
directories_UPNC <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/PDB/ANALYS"
setwd(directories_UPNC)
data_UPNC <- read.table("alla_mean.txt", header = FALSE, col.names = c("B_factor"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(data_UPC$B_factor, data_UPNC$B_factor))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 1500)
# Histogramme UPC
par(mfrow = c(1,2))
hist(data_UPC$B_factor, main = "Histogramme des B-factors normalisé des UPC",
xlab = "B-factor normalisé", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# Histogramme UPNC
hist(data_UPNC$B_factor, main = "Histogramme des B-factors normalisé des UPNC",
xlab = "B-factor normalisé", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
col_UPC <- data_UPC$B_factor
col_UPNC <- data_UPNC$B_factor
res_test <- wilcox.test(col_UPC, col_UPNC)
print(res_test)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ALPHADB/ANALYS"
setwd(directories)
datafold_UPC <- read.table("allb_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ALPHADB/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("allc_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 2000)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
## UPC
nb_values_sup_90 <- sum(datafold_UPC$pLDDT > 90)
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ALPHADB/ANALYS"
setwd(directories)
# Charger le package ggplot2
library(ggplot2)
# Charger le dataframe classbf
classbf <- read.table("pLDDT_class.txt", header = FALSE)
colnames(classbf) <- c("pLDDT", "CLASS")
# Charger le package ggplot2
library(ggplot2)
ggplot(classbf, aes(x = pLDDT, fill = CLASS)) +
geom_histogram(position = "identity", bins = 20, alpha = 0.7, color = "black") +
labs(title = "Distribution des pLDDT des UPC en fonction des CLASS", x = "pLDDT", y = "Fréquence") +
theme_minimal() +
facet_wrap(~CLASS, scales = "free_y") +
coord_cartesian(ylim = c(0, 500)) +
theme(
plot.title = element_text(size = 17),  # Ajuster la taille du titre du graphique principal
strip.text = element_text(size = 14)   # Ajuster la taille des titres des facettes
)
# Calculer la valeur moyenne pour chaque groupe
moyennes_par_groupe <- aggregate(pLDDT ~ CLASS, data = classbf, FUN = mean)
# Afficher les résultats
print(moyennes_par_groupe)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPC <- read.table("alld_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("alle_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 800)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
# Charger les données UPC
directories_UPC <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/PDB/ANALYS"
setwd(directories_UPC)
data_UPC <- read.table("all_mean.txt", header = FALSE, col.names = c("B_factor"))
# Charger les données UPNC
directories_UPNC <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/PDB/ANALYS"
setwd(directories_UPNC)
data_UPNC <- read.table("alla_mean.txt", header = FALSE, col.names = c("B_factor"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(data_UPC$B_factor, data_UPNC$B_factor))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 1500)
# Histogramme UPC
par(mfrow = c(1,2))
hist(data_UPC$B_factor, main = "Histogramme des B-factors normalisé des UPC",
xlab = "B-factor normalisé", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# Histogramme UPNC
hist(data_UPNC$B_factor, main = "Histogramme des B-factors normalisé des UPNC",
xlab = "B-factor normalisé", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
col_UPC <- data_UPC$B_factor
col_UPNC <- data_UPNC$B_factor
res_test <- wilcox.test(col_UPC, col_UPNC)
print(res_test)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ALPHADB/ANALYS"
setwd(directories)
datafold_UPC <- read.table("allb_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ALPHADB/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("allc_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 2000)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
# charger les données UPC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPC <- read.table("alld_mean.txt", header = FALSE, col.names = c("pLDDT"))
# charger les données UPNC
directories <- "/home/qcapdet/M2BI/Projet_long/Project_PUs/UPNC/ESMATLAS/ANALYS"
setwd(directories)
datafold_UPNC <- read.table("alle_mean.txt", header = FALSE, col.names = c("pLDDT"))
# Trouver les limites communes pour les deux jeux de données
xlim <- range(c(datafold_UPC$pLDDT, datafold_UPNC$pLDDT))
# Définir la plage (range) à une limite de 1500 sur l'axe y
ylim_all <- c(0, 800)
# histogramme UPC
par(mfrow = c(1,2))
hist(datafold_UPC$pLDDT, main = "Histogramme des pLDDT des UPC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
# histogramme UPNC
hist(datafold_UPNC$pLDDT, main = "Histogramme des pLDDT des UPNC",
xlab = "pLDDT", ylab = "Fréquence", col = "lightblue", border = "black", xlim = xlim, ylim = ylim_all)
colfold_UPC <- datafold_UPC$pLDDT
colfold_UPNC <- datafold_UPNC$pLDDT
# test de Mann-Whitney
resfold_test <- wilcox.test(colfold_UPC, colfold_UPNC)
print(resfold_test)
